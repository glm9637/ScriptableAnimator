using UnityEngine;
using System.Collections;
using UnityEditor;
using System.Text;
using System.IO;
using UnityEditor.Animations;
using System;
using System.Collections.Generic;

[CustomEditor(typeof(Animator))]
public class AnimationEditor : Editor
{
    public override void OnInspectorGUI()
    {

        Animator animator = (Animator)target;
        DrawDefaultInspector();
        if (GUILayout.Button("Generate Scipt"))
        {
            generateBaseClasses();
            generateAnimatorScript(animator);
            AssetDatabase.Refresh();
        }

    }

    private void generateBaseClasses()
    {
        generateStateClass();
    }

    private void generateStateClass()
    {
        string StateClass = @"using UnityEngine;
namespace IG.Generated.Internal
{
       public abstract class State
    {
        public int Layer { get; protected set; }
        public string Name {  get; protected set; }
        protected Animator animator;

        public State(Animator animator)
        {
            this.animator = animator;
        }

        public void Play(float offset = 0f)
        {
            animator.Play(Name, Layer, offset);
        }
    }
}";

        generateFile("State.cs", StateClass);
    }

    private void generateAnimatorScript(Animator animator)
    {
        // remove whitespace and minus
        var name = secureName(animator.name) + "Animator";
        var target = animator.name;
        var parameterClass = name + "Parameter";
        var content = $@"
using UnityEngine;
using System.Collections;
using IG.Generated.Internal;

namespace IG.Generated.gAnimator {{
// Autogenerated File
public class {name} : MonoBehaviour
{{

    private Animator animator;
    private static {name} instance;
        private {parameterClass} parameter;
        public {parameterClass} Parameter {{ get {{ return parameter; }} }}
    {generateLayerList(animator)}


    public void Awake() {{

        animator = GetComponent<Animator>();
        parameter = new {parameterClass}(animator);
    }}

}}

public class {parameterClass} {{

 private Animator animator;

        internal PlayerAnimatorParameter(Animator animator)
        {{
            this.animator = animator;
        }}

        {generateParameter(animator)}
}}

{generateLayerClasses(animator)}
}}
";
        generateFile(name + ".cs", content);
    }

    private string generateParameter(Animator animator)
    {
        var text = new StringBuilder();
        var hashes = new Dictionary<string, AnimatorControllerParameter>();
        var knownHashes = new List<string>();
        foreach (var parameter in animator.parameters)
        {
            var current = parameter.nameHash.ToString();
            if (hashes.ContainsKey(current))
            {
                var previous = hashes[current];
                hashes.Remove(current);
                hashes.Add(name, previous);
                knownHashes.Add(current);
                hashes.Add(parameter.name, parameter);

            }
            else if (knownHashes.Contains(current))
            {
                hashes.Add(parameter.name, parameter);
            }
            else
            {
                hashes.Add(current, parameter);
            }
        }

        foreach (var hash in hashes)
        {
            var parameter = hash.Value;
            var isHash = hash.Key != parameter.name;
            if (parameter.type == AnimatorControllerParameterType.Trigger)
            {
                text.AppendLine("   public void set" + parameter.name + "() {");
                text.AppendLine("       animator.SetTrigger(" + (isHash ? "" : "\"") + hash.Key + (isHash ? "" : "\"") + ");");
                text.AppendLine("   }");
            }
            else
            {
                var parameterType = parameter.type.ToString().ToLower();
                text.AppendLine("   public " + parameterType + " " + parameter.name + "{");
                text.AppendLine("       get {");
                text.AppendLine("           return animator.Get" + parameter.type.ToString() + "(" + (isHash ? "" : "\"") + hash.Key + (isHash ? "" : "\"") + ");");
                text.AppendLine("       }");
                text.AppendLine("       set {");
                text.AppendLine("           animator.Set" + parameter.type.ToString() + "("+ (isHash ? "" : "\"") + hash.Key + (isHash ? "" : "\"")+", value);");
                text.AppendLine("       }");
                text.AppendLine("   }");
            }
            text.AppendLine();
        }
        return text.ToString();
    }

    private string generateLayerList(Animator animator)
    {
        var text = new StringBuilder();
        for (var i = 0; i < animator.layerCount; i++)
        {
            var name = secureName(animator.GetLayerName(i));
            text.AppendLine($"public {name}Layer {name} {{ get; }}");
        }
        return text.ToString();
    }


    private string generateLayerClasses(Animator animator)
    {
        var text = new StringBuilder();
        var controller = animator.runtimeAnimatorController as AnimatorController;

        for (var i = 0; i < animator.layerCount; i++)
        {
            {
                text.AppendLine(generateStateMachineClasses(controller.layers[i].stateMachine, i, true));
            }
        }

        return text.ToString();
    }

    private string generateStateMachineClasses(AnimatorStateMachine stateMachine, int layer, bool isLayer)
    {
        var text = new StringBuilder();
        var subclasses = new StringBuilder();
        var name = secureName(stateMachine.name);
        var suffix = isLayer ? "Layer" : "StateMachine";
        text.AppendLine($"public class {name}{suffix}  : State {{");
        foreach (var state in stateMachine.states)
        {
            var stateName = secureName(state.state.name);
            text.AppendLine($"  public {stateName}State {stateName} {{ get; }}");
        }

        foreach (var subMachine in stateMachine.stateMachines)
        {
            var stateName = subMachine.stateMachine.name;
            text.AppendLine($"  public {stateName}StateMachine {stateName} {{ get; }}");
        }
        text.AppendLine($"internal {name}{suffix}(Animator animator) :  base(animator) {{");
        text.AppendLine($"  this.Layer={layer};");
        text.AppendLine($"  this.Name=\"{stateMachine.name}\";");

        foreach (var state in stateMachine.states)
        {
            var stateName = secureName(state.state.name);
            text.AppendLine($"  {stateName} = new {stateName}State(animator);");
            subclasses.AppendLine(generateStateList(state.state, layer));
        }
        foreach (var subMachine in stateMachine.stateMachines)
        {
            var stateName = subMachine.stateMachine.name;
            text.AppendLine($"  {stateName} = new {stateName}StateMachine(animator);");
            subclasses.AppendLine(generateStateMachineClasses(subMachine.stateMachine, layer, false));
        }
        text.AppendLine();
        text.AppendLine("}");
        text.AppendLine();
        text.AppendLine($@"    new public void Play(float offset = 0f)
    {{
        {secureName(stateMachine.defaultState.name)}.Play(offset);
    }}");

        text.AppendLine();
        text.AppendLine("}");
        text.AppendLine(subclasses.ToString());



        return text.ToString();
    }

    private string generateStateList(AnimatorState state, int layer)
    {
        return $@"public class {secureName(state.name)}State : State {{
    internal {secureName(state.name)}State(Animator animator) : base(animator) {{
        this.Layer={layer};
        this.Name=""{state.name}"";
    }}
}}
            ";
    }

    private void generateFile(string filename, string content)
    {
        string filePath = "Assets/Generated/Animator/";
        var fullPath = filePath + filename;
        if (!Directory.Exists(filePath))
        {
            Directory.CreateDirectory(filePath);
        }

        FileInfo fi = new FileInfo(fullPath);
        if (fi.Exists)
        {
            fi.Delete();
        }
        using (StreamWriter outfile =
            new StreamWriter(fullPath))
        {
            outfile.Write(content);
        }
    }

    private string secureName(string name)
    {
        return name.Replace(" ", "").Replace("-", "_");
    }
}
